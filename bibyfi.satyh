% vim: foldmethod=marker
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Original author: T. Suwa (github: gfngfn)                 %
% Original repository: https://github.com/gfngfn/cs-thesis      %
%                                                               %
%              Author: Nakano Masaki<namachan10777@gmail.com>   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@require: vdecoset
@require: option

% global types {{{

type bibyfi-article =
  (|
    author       : inline-text list;
    title        : inline-text;
    journal      : inline-text;
    year         : int;
    % option
    volume       : int option;
    number       : inline-text option;
    pages        : (int * int);
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-book = 
  (|
    author       : inline-text list;
    title        : inline-text;
    publisher    : inline-text;
    year         : int;
    % option
    volume       : int option;
    series       : inline-text option;
    address      : inline-text option;
    edition      : inline-text option;
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-booklet = 
  (|
    title        : inline-text;
    % option
    author       : (inline-text list) option;
    howpublished : inline-text option;
    address      : inline-text option;
    year         : int option;
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-incollection = 
  (|
    author       : inline-text list;
    title        : inline-text;
    booktitle    : inline-text;
    year         : int;
    % option
    editor       : (inline-text list) option;
    pages        : (int * int);
    organization : inline-text option;
    publisher    : inline-text option;
    address      : inline-text option;
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-inproceedings = 
  (|
    author       : inline-text list;
    title        : inline-text;
    booktitle    : inline-text;
    year         : int;
    % option
    editor       : (inline-text list) option;
    pages        : (int * int);
    organization : inline-text option;
    publisher    : inline-text option;
    address      : inline-text option;
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-proceedings = 
  (|
    title        : inline-text;
    year         : int;
    % option
    editor       : (inline-text list) option;
    publisher    : inline-text option;
    organization : inline-text option;
    address      : inline-text option;
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-manual = 
  (|
    title        : inline-text;
    % option
    author       : (inline-text list) option;
    organization : inline-text option;
    address      : inline-text option;
    edition      : inline-text option;
    month        : inline-text option;
    year         : int option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-masterthesis = 
  (|
    author       : inline-text list;
    title        : inline-text;
    school       : inline-text;
    year         : int;
    % option
    address      : inline-text option;
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-phdthesis = 
  (|
    author       : inline-text list;
    title        : inline-text;
    school       : inline-text;
    year         : int;
    % option
    address      : inline-text option;
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-techreport = 
  (|
    author       : inline-text list;
    title        : inline-text;
    institution  : inline-text;
    year         : int;
    % option
    typeof       : inline-text option;
    number       : int option;
    address      : inline-text option;
    month        : inline-text option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-misc = 
  (|
    % option
    author       : (inline-text list) option;
    title        : inline-text option;
    howpublished : inline-text option;
    month        : inline-text option;
    year         : int option;
    note         : inline-text option;
    key          : inline-text option;
  |)

type bibyfi-unpublished = 
  (|
    % option
    author       : inline-text list;
    title        : inline-text;
    note         : inline-text;
    %option
    month        : inline-text option;
    year         : int option;
    key          : inline-text option;
  |)

% }}}

type bibyfi-item =
  | Article of bibyfi-article
  | Book of bibyfi-book
  | Booklet of bibyfi-booklet
  | InCollection of bibyfi-incollection
  | InProceedings of bibyfi-inproceedings
  | Manual of bibyfi-manual
  | MasterThesis of bibyfi-masterthesis
  | PhDThesis of bibyfi-phdthesis
  | Misc of bibyfi-misc
  | Proceedings of bibyfi-proceedings
  | TechReport of bibyfi-techreport
  | Unpublished of bibyfi-unpublished

module BiByFi: sig
  direct \cite : [string list] inline-cmd
  direct +makebibliography : [context -> int -> bibyfi-item -> block-boxes; (string * bibyfi-item) list] block-cmd
  direct \BiByFi : [] inline-cmd

  val join-authors : inline-text -> inline-text -> inline-text list -> inline-text
  val make-entry : context -> inline-boxes -> inline-boxes -> block-boxes
end = struct
  let bib-left-padding = 20pt

  % internal functions {{{

  let int-of-string s =
    let digit-of-string s = match s with
      | `0` -> Some(0)
      | `1` -> Some(1)
      | `2` -> Some(2)
      | `3` -> Some(3)
      | `4` -> Some(4)
      | `5` -> Some(5)
      | `6` -> Some(6)
      | `7` -> Some(7)
      | `8` -> Some(8)
      | `9` -> Some(9)
      | _   -> None
    in
    let-rec f exp s =
      let l = string-length s in
      match l with
      | 0 -> None
      | 1 -> 
        (Option.map (fun d -> exp * d) (digit-of-string (string-sub s (l - 1) 1)))
      | _ ->
        Option.bind
          (f (exp * 10) (string-sub s 0 (l - 1)))
          (fun n -> Option.map (fun d -> n + exp * d) (digit-of-string (string-sub s (l - 1) 1)))
    in
    f 1 s

  % }}}

  % helpers for style file {{{
  let join-authors sep sep-last authors =
    match List.reverse authors with
    | []                    -> {}
    | it :: []              -> it
    | it2 :: it1 :: []      -> {#it1;#sep-last;#it2;}
    | it-last :: it-rest ->
      let its = it-rest
        |> List.fold-left (fun acc it -> {#acc;#it;#sep;}) {}
      in
        {#its;#sep-last;#it-last;}

  let make-entry ctx ib-num ib-main =
    let ib =
      inline-skip (0pt -' get-natural-width ib-num)
        ++ ib-num ++ ib-main ++ inline-fil
    in
    let pads = (20pt, 0pt, 0pt, 0pt) in
    block-frame-breakable ctx pads VDecoSet.empty (fun ctx -> line-break true true ctx ib)
  % }}}

  % implementations {{{
  let-mutable cite-logs <- []

  let-inline ctx \BiByFi =
    let size = get-font-size ctx in
    let f = read-inline ctx in
    let fd = ctx |> set-manual-rising (0pt -' (size *' 0.25)) |> read-inline in
    let ib = 
      f {BiB} ++ kern (size *' 0.05) ++ fd{Y} ++ f{F} ++ kern(size *' 0.05) ++ fd{I}
    in
    script-guard Latin (no-break ib)

  let join-references-smartly =
    List.fold-left-adjacent (fun acc ref-n ref-n-prev ref-n-next -> (
      match (ref-n-prev, ref-n-next) with
      | (_, None) -> acc ^ arabic ref-n
      | (None, Some(n-next)) ->
        if n-next == ref-n + 1
        then (arabic ref-n) ^ `-`
        else (arabic ref-n) ^ `, `#
      | (Some(n-prev), Some(n-next)) ->
        if n-next == ref-n + 1 && n-prev + 1 == ref-n
        % nothing to do because `-` was printed
        then acc
        else (
          if n-next == ref-n + 1
          % 1, 3-4
          then acc ^ (arabic ref-n) ^ `-`
          % 1, 3
          else acc ^ (arabic ref-n) ^ `, `#
        )
      )) ` `

  let-inline ctx \cite labels =
    let sacc =
      labels
      |> List.map (fun label -> (
        let () = cite-logs <- (
          if List.fold-left (fun acc cited -> (string-same cited label) || acc) false !cite-logs
          then !cite-logs
          else label :: !cite-logs
        )
        in
        match get-cross-reference (`__bibyfi:` ^ label) with
          | None -> -1
          | Some(l) -> Option.from (-1) (int-of-string l)
        ))
      |> join-references-smartly
    in
      inline-skip 2pt ++ read-inline ctx (embed-string (`[` ^ sacc ^ `]`))

  let-rec sort-same f src refs =
    let pick label lst = lst |> List.filter (fun l -> f l label) |> List.nth 0 in
    match refs with
    | [] -> []
    | label1 :: tl -> (match pick label1 src with
      | Some (l) -> l :: sort-same f src tl
      | None -> sort-same f src tl)

  let-block ctx +makebibliography theme bibs =
      let bibs =
        sort-same (fun (cited, _) label -> string-same label cited) bibs !cite-logs
        |> List.reverse
      in
      let () =
        bibs |> List.iteri (fun i (label, _) -> (
          register-cross-reference (`__bibyfi:` ^ label) (arabic (i + 1))
        ))
      in
        bibs |> List.fold-lefti (fun i bbacc (_, bibitem) -> (
          bbacc +++ theme ctx  (i + 1) bibitem
        )) block-nil
  % }}}
end
