@import: bibyfi

module BiByFiIEEETran : sig
  val theme : context -> int -> bibyfi-item -> block-boxes
end = struct

  let font-ratio-latin = 1.
  let book-title-font = (`Junicode-it`, font-ratio-latin, 0.)

  let mk-index ctx index =
    let s = `[` ^ arabic index ^ `] `# in
    read-inline ctx (embed-string s)

  let-inline ctx \book-title it =
    let ctx = ctx
      |> set-font Latin book-title-font
    in
      read-inline ctx it

  let mk-pages (s, e) =
    let it-s = embed-string s in
    let it-e = embed-string s in
    {pp. #it-s;–#it-e;}

  let mk-year-month year month =
    let it-year = embed-string year in
    match month with
    | None -> {#it-year;}
    | Some(month) -> (
      let it-month = embed-string month in
      {#it-month;\ #it-year;}
    )

  let-inline ctx \space l =
    inline-skip l

  let endmarkers-en =
    List.map string-explode [`.`; `?`; `!`]

  let-rec head-match xs ys = match (xs, ys) with
    | ([], []) -> true
    | (x :: xs, y :: ys) -> x == y && head-match xs ys
    | _ -> true

  let tail-match xs ys =
    head-match (List.reverse xs) (List.reverse ys)

  let mk-title title sep =
    let it-title = embed-string title in
    let title = string-explode title in
    let title-has-endmark =
      endmarkers-en
      |> List.map (fun pattern -> tail-match pattern title)
      |> List.fold-left ( || ) false
    in
      if title-has-endmark
      then {“#it-title;”}
      else {“#it-title;#sep;”}

  let mk-publisher addr publisher = match (addr, publisher) with
    | (Some(addr), Some(publisher)) -> (
      let it-addr = embed-string addr in
      let it-publisher = embed-string publisher in
      Some({#it-addr;:\ #it-publisher;}))
    | _ -> None

  let mk-article r =
      let it-journal = embed-string r#journal in
      let it-note = Option.map embed-string r#note in
      let it-key = Option.map embed-string r#key in
      BiByFi.join-elements {,\ } {.} [
        BiByFi.lift-elem (BiByFi.join-authors {,\ } {and\ } (List.map embed-string r#author));
        Some (|
          not-tail = fun sep     -> (let it-title = mk-title r#title sep     in {#it-title;\space(10pt);});
          tail     = fun periodo -> (let it-title = mk-title r#title periodo in {#it-title;});
        |);
        BiByFi.lift-elem {\book-title{#it-journal;}};
        BiByFi.lift-elem (mk-pages r#pages);
        BiByFi.map-elem  (Option.map
          (fun v -> (
            let it-v = embed-string v
            in {vol. #it-v;})) r#volume);
        BiByFi.map-elem  (Option.map
          (fun n -> (
            let it-n = embed-string n in
            {no. #it-n;})) r#number);
        BiByFi.lift-elem (mk-year-month r#year r#month);
        BiByFi.map-elem it-note;
        BiByFi.map-elem it-key;
      ]


  let mk-inproceedings r =
    let it-authors = BiByFi.join-authors {,\ } {and\ } (List.map embed-string r#author) in
    let it-booktitle = embed-string r#booktitle in
    let it-editors = r#editor
      |> Option.map (fun editors -> BiByFi.join-authors {,\ } {and\ } (List.map embed-string editors))
      |> Option.map (fun it-editor -> {#it-editor;,\ Eds.}) in
    let it-note = Option.map embed-string r#note in
    let it-key = Option.map embed-string r#key in
    let it-organization = Option.map embed-string r#organization in
    let it-publisher = mk-publisher r#address r#publisher in
    BiByFi.join-elements {,\ } {.} [
      BiByFi.lift-elem it-authors;
      Some (|
        not-tail = fun sep     -> (let it-title = mk-title r#title sep     in {#it-title;\space(10pt);});
        tail     = fun periodo -> (let it-title = mk-title r#title periodo in {#it-title;});
      |);
      BiByFi.lift-elem {in\ \book-title{#it-booktitle;}};
      BiByFi.map-elem it-editors;
      BiByFi.map-elem it-organization;
      BiByFi.map-elem it-publisher;
      BiByFi.lift-elem (mk-year-month r#year r#month);
      BiByFi.map-elem (Option.map mk-pages r#pages);
      BiByFi.map-elem it-note;
      BiByFi.map-elem it-key;
    ]

  let theme ctx index bib-item =
    match bib-item with
    | Article(r) ->
      BiByFi.make-entry ctx (mk-index ctx index) (read-inline ctx (mk-article r))
    | InProceedings(r) ->
      BiByFi.make-entry ctx (mk-index ctx index) (read-inline ctx (mk-inproceedings r))
    | _ ->
      BiByFi.make-entry ctx (mk-index ctx index) (read-inline ctx {yet implemented})
end
